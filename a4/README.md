# The One-file Program Project: Step 4 - Bytecode Generation using ASM

After the first two Assignments, you should have implemented support for parsing, symbol table construction, and semantic analysis for input programs in OFP. In Assignment 4, your task is to generate Java bytecode using the **ASM** bytecode manipulation library corresponding to the input OFP code, i.e., for a given valid X.*ofp* file, produce a corresponding valid X.*class* file. After the bytecode is generated, it should also be **executed**. In particular:

* `void main() { .. }` in OFP should translate to `public static void main(Strings[] args) { .. }` in Java

* `int max(int a, int b) { .. }` in OFP should translate to `private static int max(int a, int b) { .. }` in Java

* `int`, `float`, `bool`, `char`, `string` in OFP should translate to `int`, `double`, `boolean`, `char`, `java.lang.String` in Java

* `print` and `println` in OFP should translate to `System.out.print()`, `System.out.println()` in Java

* String access in OFP (e.g. `c = str[7];`) is replaced by a call to the String method charAt (e.g. `c = str.charAt(7);`) in Java

The two final lectures in this course, *"Stack Machines and Bytecode"* and *"Generating Bytecode with ASM"*, discuss the implementation details related to Assignment 4 — please read the lecture slides carefully.

**Note related to Assignments 2 and 3:**
Your implementation in Assignment 2 and 3 should not affect your grade for Assignment 4 (e.g., if you failed to properly check for some type mismatch errors in Assignment 2); furthermore, you can assume that input programs are valid OFP programs.
Make sure that valid OFP programs are accepted by your parser + symbol table + type checker, though — if we cannot test Assignment 4 tasks because of Assignment 2 and 3 issues, this will affect your grade.

If you are not confident about your semantic analysis implementation (e.g., *CheckRefListener* and *TypeCheckingVisitor* from Assignment 2), you might even consider commenting out the corresponding parts of the code in your main Java class (i.e., after constructing the symbol table, go directly to the bytecode generation step and skip the semantic analyses).

## Recommended Approach

We recommend you to implement a visitor for your parse tree. Once the parse tree traversal is finished, the resulting bytecode should then be saved into a .class file; afterwards, it should also be executed.
We also recommend a small-step approach where you add one OFP language feature in each step. The best way to learn about Java bytecode is to write small Java programs using a specific feature and then use the command tool javap to inspect the bytecode generated by the Java compiler.
Information about various bytecode instructions can be found in [Wikipedia](https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions) as well as [the official JVM documentation](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html).

The threshold to get started with the ASM bytecode library is rather steep. To make it worse, good resources (e.g., tutorials) are hard to find on the Internet. We strongly recommend you to carefully study the material presented in the lecture "Generating Bytecode using ASM" before you start working on this assignment.

### We provide

1. A JAR file containing the ASM library: *asm-all-5.0.1.jar*

2. Five Java programs showing how to use ASM to generate bytecode and then execute it: *asm_usage_examples.zip*

3. An updated set of OFP test programs where we have added a few small programs testing OFP features that are important for the bytecode generation: *ofp_test_assignment4.zip* (remember that these tests are not exhaustive, and you should write your own additional tests, if necessary!)

We provide ASM version 5.0.1, the version that was used in the lecture slides. Feel free to use newer versions (but do not expect support).

See further documentation in the [ASM 5 API documentation](https://javadoc.io/doc/org.ow2.asm/asm/5.0/index.html).

## Report

Before the given deadline for Assignment 4 you must upload your solution to Moodle.

Your submission shall contain:

1. The final OFP grammar file (*.g4*) that you used to generate the source code for your parser and listeners/visitors

2. All files required to compile and run the program

3. A number of suitable test (input) programs

4. Instructions for how to compile and run your program (if necessary)

**Please also observe:**

* If you work on practical assignments in a group of two students, please submit the assignment **only once for each group** — the submitter should state the name of their group mate.

* Your implementation of Assignment 4 must be carried out in Java (any version newer than Java **6**).
*It is prohibited to use any third-party libraries in your project (with the exception of ANTLR and ASM, of course).

* Finally, make sure it is easy to switch from one input OFP program to another when running your program.

## Attached files

* [asm_usage_examples.zip](../asm_usage_examples.zip)

* [asm-all-5.0.1.jar](../asm-all-5.0.1.jar)

* [ofp_test_assignment4.zip](../ofp_test_assignment4.zip)
