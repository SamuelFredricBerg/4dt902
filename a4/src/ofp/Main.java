package ofp;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

import org.antlr.v4.runtime.BufferedTokenStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.tree.ParseTreeProperty;
import org.antlr.v4.runtime.tree.ParseTreeWalker;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.TraceClassVisitor;
import org.antlr.v4.gui.Trees;

import generated.OFPLexer;
import generated.OFPParser;

public class Main extends ClassLoader implements Opcodes {

  public static void main(String[] args) {

    // Select test program
    String inputDir = "/home/fred/Documents/4dt902/a4/src/input/";
    String testFile = "float"; // Change test file here
    String testProgram = testFile + ".ofp";
    String outputDir = "/home/fred/Documents/4dt902/a4/src/output/";

    // Check if input ends with ".ofp"
    if (!testProgram.endsWith(".ofp")) {
      System.out.println("\nPrograms most end with suffix .ofp! Found " + inputDir + testProgram);
      System.exit(-1);
    }
    System.out.println("Reading test program from: " + inputDir + testProgram);

    // Parse input program
    System.out.println("\nParsing started");
    OFPParser parser = null;
    OFPParser.ProgramContext root = null;
    try {
      CharStream inputStream = CharStreams.fromFileName(inputDir + testProgram);
      OFPLexer lexer = new OFPLexer(inputStream);
      parser = new OFPParser(new BufferedTokenStream(lexer));
      root = parser.program();
    } catch (IOException e) {
      e.printStackTrace();
    }
    System.out.println("\nParsing completed");

    // Display tree
    // Trees.inspect(root, parser); // Uncomment to display tree

    // Indented tree print
    System.out.println("\n===== Print Listener =====");
    ParseTreeWalker walkerTest = new ParseTreeWalker();
    PrintListener printListener = new PrintListener();
    walkerTest.walk(printListener, root);

    // Symbol table construction
    ParseTreeWalker walker = new ParseTreeWalker();
    SymbolTableListener stListener = new SymbolTableListener();
    walker.walk(stListener, root);
    stListener.printSymbolTable();

    ParseTreeProperty<Scope> scopes = stListener.getScope();

    // Symbol reference checking
    System.out.println("\n===== Symbol Refrence Checking =====");
    CheckRefListener checkRefListener = new CheckRefListener(scopes, stListener.getGlobalScope());
    walker.walk(checkRefListener, root);
    checkRefListener.reportErrors();

    // Type checking
    System.out.println("===== Type Checking Errors =====");
    TypeCheckingVisitor tcVisitor = new TypeCheckingVisitor(scopes, stListener.getGlobalScope());
    tcVisitor.visit(root);

    // Python Genertion
    System.out.println("\nGenerating Python code...");

    String outputPythonFile = outputDir + "python/" + testFile + ".py";

    PythonGenerator pythonCodeGenerator = new PythonGenerator(scopes);
    String generatedPythonCode = pythonCodeGenerator.visit(root);

    try {
      Files.write(Paths.get(outputPythonFile), generatedPythonCode.getBytes(),
          StandardOpenOption.CREATE,
          StandardOpenOption.TRUNCATE_EXISTING);
      System.out.println("Python code generated and written to: " +
          outputPythonFile);
    } catch (IOException e) {
      System.err.println("Error writing Python code to file: " + e.getMessage());
    }

    // Bytecode generation
    System.out.println("\nBytecode generation started\n");
    BytecodeGenerator byteGen = new BytecodeGenerator(testFile, scopes, stListener.getGlobalScope());
    byteGen.visit(root);
    ClassWriter cw = byteGen.getClassWriter();
    try {
      byte[] bytecode = cw.toByteArray();

      System.out.println("\nVerifying generated bytecode:\n");
      ClassReader cr = new ClassReader(bytecode);
      ClassVisitor cv_trace = new TraceClassVisitor(new PrintWriter(System.out));
      ClassVisitor cv_check = new CheckClassAdapter(cv_trace, true);
      cr.accept(cv_check, 0);

      FileOutputStream fos = new FileOutputStream(outputDir + "bytecode/" + testFile + ".class");
      fos.write(bytecode);
      fos.close();
      System.out.println("Bytecode written to: " + outputDir + "bytecode/" + testFile + ".class");

      System.out.println("\nExecuting generated bytecode:\n");
      Main loader = new Main();
      Class<?> exampleClass = loader.defineClass(testFile, bytecode, 0, bytecode.length);
      exampleClass.getMethods()[0].invoke(null, (Object) null);
    } catch (Exception e) {
      System.err.println("Error writing bytecode to file: " + e.getMessage());
      e.printStackTrace();
    }
  }
}
